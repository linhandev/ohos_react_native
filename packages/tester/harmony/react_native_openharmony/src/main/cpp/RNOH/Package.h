/**
 * Copyright (c) 2024 Huawei Technologies Co., Ltd.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once
#include <react/renderer/componentregistry/ComponentDescriptorProvider.h>
#include "RNOH/ArkTSMessageHandler.h"
#include "RNOH/ComponentInstanceFactory.h"
#include "RNOH/EventEmitRequestHandler.h"
#include "RNOH/GlobalJSIBinder.h"
#include "RNOH/MutationsToNapiConverter.h"
#include "RNOH/ShadowViewRegistry.h"
#include "RNOH/TurboModule.h"
#include "RNOH/TurboModuleFactory.h"
#include "RNOH/UIManagerModule.h"

namespace rnoh {
/**
 * @actor RNOH_LIBRARY, CODEGEN
 *
 * An abstract factory. Use it to register custom Components, Turbo Modules or
 * other unusual elements.
 *
 * RNOH library shouldn't define more than one concrete Package class.
 *
 * Tip: Codegen generates BasePackage that extends this class to register
 * generated items.
 */
class Package {
 public:
  using Shared = std::shared_ptr<Package>;

  /**
   * @actor RNOH_LIBRARY
   * RNOH heavily utilizes contexts to inject new dependencies in
   * a non-breaking manner.
   */
  struct Context : ComponentInstance::Context {
    ShadowViewRegistry::Shared shadowViewRegistry;
  };

 protected:
  /**
   * @actor RNOH_LIBRARY
   */
  Context m_ctx;

 public:
  /**
   * @actor RNOH_LIBRARY
   * RNOH libraries should preserve this constructor interface to make a
   * library auto-linkable.
   */
  Package(Context ctx);

  virtual ~Package(){};

  // COMPONENTS ————————————————————————————————————————————————————————————————

  /**
   * @actor RNOH_LIBRARY
   * @architecture: C-API
   * Override this method to register RNOH-specific implementation of custom
   * components.
   *
   * ComponentInstance is an equivalent of RN Android's ViewManager. However,
   * unlike ViewManagers, which are instantiated once per component type,
   * ComponentInstances are created for each individual instance of a component.
   */
  virtual ComponentInstance::Shared createComponentInstance(
      const ComponentInstance::Context& ctx) {
    return nullptr;
  };

  /**
   * @actor RNOH_LIBRARY
   * @architecture: C-API
   * @deprecated: Override `createComponentInstance` instead (latestRNOHVersion:
   * 0.72.27).
   */
  virtual ComponentInstanceFactoryDelegate::Shared
  createComponentInstanceFactoryDelegate();

  /**
   * @actor RNOH_LIBRARY, CODEGEN
   * ComponentDescriptor provides platform-agnostic information
   * about custom components to RN.
   */
  virtual std::vector<facebook::react::ComponentDescriptorProvider>
  createComponentDescriptorProviders();

  /**
   * @actor RNOH_LIBRARY, CODEGEN
   * ComponentJSIBinders create ViewConfigs.
   * ViewConfig describe component data that can be sent between JS and Native
   * sides. RN requires ViewConfigs. Check the doc comment in
   * ComponentJSIBinder.h for more info.
   */
  virtual ComponentJSIBinderByString createComponentJSIBinderByName();

  /**
   * @internal
   * @architecture: ArkTS & ArkTS components in C-API architecture
   *
   * When RNOH was in a very early stage, and ArkTS architecture was used,
   * ComponentNapiBinder was used to pass properties to ArkTS side.
   *
   * Later, a new approach was introduced that handles passing those properties
   * automatically to ArkTS, so libraries aren't expected to provide
   * ComponentNapiBinders.
   */
  virtual ComponentNapiBinderByString createComponentNapiBinderByName();

  /**
   * @actor RNOH_LIBRARY, CODEGEN
   * @architecture: ArkTS & ArkTS components in C-API architecture
   *
   * Receives events from the ArkTS side and invokes the
   * appropriate method on the corresponding EventEmitter.
   *
   * The purpose of EventEmitRequestHandler is relaying events
   * from ArkTS to the (usually) generated, component-specific EventEmitters.
   * This class was needed by core components in ArkTS architecture because RN
   * ships with custom event emitters.
   *
   * EventEmitRequestHandler is still needed for ArkTS components in C-API, but
   * it is generated by codegen. ComponentInstances can directly interact with
   * EventEmitters.
   */
  virtual EventEmitRequestHandlers createEventEmitRequestHandlers();

  // TURBO MODULES —————————————————————————————————————————————————————————————

  /**
   * @actor RNOH_LIBRARY, CODEGEN
   * Creates a factory that instantiates Turbo Modules.
   * Turbo Modules are usually implemented on the ArkTS side, so these
   * TurboModuleFactoryDelegates usually act as a glue layer between JS and
   * ArkTS.
   *
   * Override this method to register C++ Turbo Modules.
   *
   * (This interface could be improved to allow registering Turbo Modules
   * directly, but this method is used by codegen most of the time anyway.)
   */
  virtual std::unique_ptr<TurboModuleFactoryDelegate>
  createTurboModuleFactoryDelegate();

  // MISC ——————————————————————————————————————————————————————————————————————

  /**
   * @actor RNOH_LIBRARY
   * @architecture: C-API
   * Override this class if you want to process a component-agnostic message,
   * sent for example, by a Turbo Module on ArkTS side.
   */
  virtual std::vector<ArkTSMessageHandler::Shared>
  createArkTSMessageHandlers() {
    return {};
  };

  /**
   * @actor RNOH_LIBRARY
   * Provide GlobalJSIBinders, when Turbo Modules are too limiting for your use
   * case.
   */
  virtual GlobalJSIBinders createGlobalJSIBinders(
      const GlobalJSIBinder::Context& ctx);

  /**
   * @actor RNOH_LIBRARY
   * @deprecated: Override
   * `createGlobalJSIBinders(const GlobalJSIBinder::Context& ctx)` instead
   * (latestRNOHVersion: 0.77.1)
   *
   * It is deprecated because GlobalJSIBinder requires GlobalJSIBinder::Context
   * and this method doesn't provide that context.
   */
  virtual GlobalJSIBinders createGlobalJSIBinders();
};
} // namespace rnoh